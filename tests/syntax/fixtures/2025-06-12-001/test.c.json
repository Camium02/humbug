{
  "source_file": "tests/syntax/fixtures/2025-06-12-001/test.c",
  "language": "C",
  "tokens": [
    {
      "type": "COMMENT",
      "value": "/*\n * main.c\n *\tOpening file for the sinister tool.\n */",
      "start": 0
    },
    {
      "type": "ERROR",
      "value": "\n",
      "start": 55
    },
    {
      "type": "PREPROCESSOR",
      "value": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/fcntl.h>\n\n/*\n * 32-bit ELF base types.\n */\ntypedef uint32_t elf32_addr;\ntypedef uint16_t elf32_half;\ntypedef uint32_t elf32_off;\ntypedef int32_t elf32_sword;\ntypedef uint32_t elf32_word;\n\n/*\n * ELF header.\n */\nstruct elf32_hdr {\n\tunsigned char e_ident[16];\n\telf32_half e_type;\n\telf32_half e_machine;\n\telf32_word e_version;\n\telf32_addr e_entry;\n\telf32_off e_phoff;\n\telf32_off e_shoff;\n\telf32_word e_flags;\n\telf32_half e_ehsize;\n\telf32_half e_phentsize;\n\telf32_half e_phnum;\n\telf32_half e_shentsize;\n\telf32_half e_shnum;\n\telf32_half e_shstrndx;\n};\n\n/*\n * e_ident field offsets.\n */\n#define EI_MAG0 0\n#define EI_MAG1 1\n#define EI_MAG2 2\n#define EI_MAG3 3\n#define EI_CLASS 4\n#define EI_DATA 5\n#define EI_VERSION 6\n#define EI_PAD 7\n\n/*\n * EI_DATA field values.\n */\n#define ELFDATANONE 0\n#define ELFDATA2LSB 1\n#define ELFDATA2MSB 2\n\n/*\n * ELF file types (e_type in elf32_hdr).\n */\n#define ET_NONE 0\n#define ET_REL 1\n#define ET_EXEC 2\n#define ET_DYN 3\n#define ET_CORE 4\n#define ET_LOPROC 0xff00\n#define ET_HIPROC 0xffff\n\n/*\n * ELF program header.\n */\nstruct elf32_phdr {\n\telf32_word p_type;\n\telf32_off p_offset;\n\telf32_addr p_vaddr;\n\telf32_addr p_paddr;\n\telf32_word p_filesz;\n\telf32_word p_memsz;\n\telf32_word p_flags;\n\telf32_word p_align;\n};\n\n/*\n * Segment types stored in the image headers.\n */\n#define PT_NULL 0\n#define PT_LOAD 1\n#define PT_DYNAMIC 2\n#define PT_INTERP 3\n#define PT_NOTE 4\n#define PT_SHLIB 5\n#define PT_PHDR 6\n#define PT_TLS 7\n\n/*\n * ELF section header.\n */\nstruct elf32_shdr {\n\telf32_word sh_name;\n\telf32_word sh_type;\n\telf32_word sh_flags;\n\telf32_addr sh_addr;\n\telf32_off sh_offset;\n\telf32_word sh_size;\n\telf32_word sh_link;\n\telf32_word sh_info;\n\telf32_word sh_addralign;\n\telf32_word sh_entsize;\n};\n\n/*\n * Section indexes.\n */\n#define SHN_UNDEF 0\n#define SHN_LORESERVE 0xff00\n#define SHN_LOPROC 0xff00\n#define SHN_HIPROC 0xff1f\n#define SHN_ABS 0xfff1\n#define SHN_COMMON 0xfff2\n#define SHN_HIRESERVE 0xffff\n\n/*\n * Section types.\n */\n#define SHT_NULL 0\n#define SHT_PROGBITS 1\n#define SHT_SYMTAB 2\n#define SHT_STRTAB 3\n#define SHT_RELA 4\n#define SHT_HASH 5\n#define SHT_DYNAMIC 6\n#define SHT_NOTE 7\n#define SHT_NOBITS 8\n#define SHT_REL 9\n#define SHT_SHLIB 10\n#define SHT_DYNSYM 11\n#define SHT_LOPROC 0x70000000\n#define SHT_HIPROC 0x7fffffff\n#define SHT_LOUSER 0x80000000\n#define SHT_HIUSER 0xffffffff\n\n/*\n * Section flags.\n */\n#define SHF_WRITE 0x1\n#define SHF_ALLOC 0x2\n#define SHF_EXECINSTR 0x4\n\n/*\n * Symbol table entry.\n */\nstruct elf32_sym {\n\telf32_word st_name;\n\telf32_addr st_value;\n\telf32_word st_size;\n\tunsigned char st_info;\n\tunsigned char st_other;\n\telf32_half st_shndx;\n};\n\n/*\n * Ubicom32 opcodes.\n */\nenum opcodes {\n\tOP_ADD_1,\n\tOP_ADD_2,\n\tOP_ADD_4,\n\tOP_ADDC,\n\tOP_AND_1,\n\tOP_AND_2,\n\tOP_AND_4,\n\tOP_ASR_1,\n\tOP_ASR_2,\n\tOP_ASR_4,\n\tOP_BCLR,\n\tOP_BFEXTU,\n\tOP_BFRVRS,\n\tOP_BKPT,\n\tOP_BSET,\n\tOP_BTST,\n\tOP_CALL,\n\tOP_CALLI,\n\tOP_CMPI,\n\tOP_CRCGEN,\n\tOP_EXT_1,\n\tOP_EXT_2,\n\tOP_FLUSH,\n\tOP_IREAD,\n\tOP_IWRITE,\n\tOP_JMPF_S_F,\n\tOP_JMPLO_S_F,\n\tOP_JMPHS_S_F,\n\tOP_JMPEQ_S_F,\n\tOP_JMPGE_S_F,\n\tOP_JMPGT_S_F,\n\tOP_JMPHI_S_F,\n\tOP_JMPLE_S_F,\n\tOP_JMPLS_S_F,\n\tOP_JMPLT_S_F,\n\tOP_JMPMI_S_F,\n\tOP_JMPNE_S_F,\n\tOP_JMPPL_S_F,\n\tOP_JMPT_S_F,\n\tOP_JMPVC_S_F,\n\tOP_JMPVS_S_F,\n\tOP_JMPF_S_T,\n\tOP_JMPLO_S_T,\n\tOP_JMPHS_S_T,\n\tOP_JMPEQ_S_T,\n\tOP_JMPGE_S_T,\n\tOP_JMPGT_S_T,\n\tOP_JMPHI_S_T,\n\tOP_JMPLE_S_T,\n\tOP_JMPLS_S_T,\n\tOP_JMPLT_S_T,\n\tOP_JMPMI_S_T,\n\tOP_JMPNE_S_T,\n\tOP_JMPPL_S_T,\n\tOP_JMPT_S_T,\n\tOP_JMPVC_S_T,\n\tOP_JMPVS_S_T,\n\tOP_JMPF_W_F,\n\tOP_JMPLO_W_F,\n\tOP_JMPHS_W_F,\n\tOP_JMPEQ_W_F,\n\tOP_JMPGE_W_F,\n\tOP_JMPGT_W_F,\n\tOP_JMPHI_W_F,\n\tOP_JMPLE_W_F,\n\tOP_JMPLS_W_F,\n\tOP_JMPLT_W_F,\n\tOP_JMPMI_W_F,\n\tOP_JMPNE_W_F,\n\tOP_JMPPL_W_F,\n\tOP_JMPT_W_F,\n\tOP_JMPVC_W_F,\n\tOP_JMPVS_W_F,\n\tOP_JMPF_W_T,\n\tOP_JMPLO_W_T,\n\tOP_JMPHS_W_T,\n\tOP_JMPEQ_W_T,\n\tOP_JMPGE_W_T,\n\tOP_JMPGT_W_T,\n\tOP_JMPHI_W_T,\n\tOP_JMPLE_W_T,\n\tOP_JMPLS_W_T,\n\tOP_JMPLT_W_T,\n\tOP_JMPMI_W_T,\n\tOP_JMPNE_W_T,\n\tOP_JMPPL_W_T,\n\tOP_JMPT_W_T,\n\tOP_JMPVC_W_T,\n\tOP_JMPVS_W_T,\n\tOP_LEA_1,\n\tOP_LEA_2,\n\tOP_LEA_4,\n\tOP_LSL_1,\n\tOP_LSL_2,\n\tOP_LSL_4,\n\tOP_LSR_1,\n\tOP_LSR_2,\n\tOP_LSR_4,\n\tOP_MAC,\n\tOP_MADD_2,\n\tOP_MADD_2_C,\n\tOP_MADD_2_T,\n\tOP_MADD_2_C_T,\n\tOP_MADD_4,\n\tOP_MADD_4_C,\n\tOP_MADD_4_T,\n\tOP_MADD_4_C_T,\n\tOP_MACF,\n\tOP_MACF_C,\n\tOP_MACF_T,\n\tOP_MACF_C_T,\n\tOP_MACS,\n\tOP_MACS_C,\n\tOP_MACS_T,\n\tOP_MACS_C_T,\n\tOP_MACU,\n\tOP_MACU_C,\n\tOP_MACU_T,\n\tOP_MACU_C_T,\n\tOP_MACUS,\n\tOP_MACUS_C,\n\tOP_MACUS_T,\n\tOP_MACUS_C_T,\n\tOP_MERGE,\n\tOP_MOVE_1,\n\tOP_MOVE_2,\n\tOP_MOVE_4,\n\tOP_MOVEA,\n\tOP_MOVEAI,\n\tOP_MOVEI,\n\tOP_MSUB_2,\n\tOP_MSUB_2_C,\n\tOP_MSUB_2_T,\n\tOP_MSUB_2_C_T,\n\tOP_MSUB_4,\n\tOP_MSUB_4_C,\n\tOP_MSUB_4_T,\n\tOP_MSUB_4_C_T,\n\tOP_MSUF,\n\tOP_MSUF_C,\n\tOP_MSUF_T,\n\tOP_MSUF_C_T,\n\tOP_MULF,\n\tOP_MULF_C,\n\tOP_MULF_T,\n\tOP_MULF_C_T,\n\tOP_MULS,\n\tOP_MULS_T,\n\tOP_MULS_4,\n\tOP_MULU,\n\tOP_MULU_T,\n\tOP_MULU_4,\n\tOP_NOT_2,\n\tOP_NOT_4,\n\tOP_OR_1,\n\tOP_OR_2,\n\tOP_OR_4,\n\tOP_PDEC,\n\tOP_PREFETCH,\n\tOP_PXADDS,\n\tOP_PXADDS_U,\n\tOP_PXBLEND,\n\tOP_PXBLEND_T,\n\tOP_PXCNV,\n\tOP_PXCNV_T,\n\tOP_PXHI,\n\tOP_PXHI_S,\n\tOP_PXVI,\n\tOP_PXVI_S,\n\tOP_RET,\n\tOP_SETCSR,\n\tOP_SHFTD,\n\tOP_SHMRG_1,\n\tOP_SHMRG_2,\n\tOP_SUB_1,\n\tOP_SUB_2,\n\tOP_SUB_4,\n\tOP_SUBC,\n\tOP_SUSPEND,\n\tOP_SWAPB_2,\n\tOP_SWAPB_4,\n\tOP_SYNC,\n\tOP_SYSCALL,\n\tOP_SYSRET,\n\tOP_XOR_1,\n\tOP_XOR_2,\n\tOP_XOR_4,\n\tOP_UNUSED\n};\n\nstruct opcode {\n\tconst char name[10];\t\t\t/* Opcode name */\n\tint size;\t\t\t\t/* Size of the instruction operation */\n\tint isa_bitmap;\t\t\t\t/* Bitmap of ISA versions in which supported */\n};\n\n#define ISA_1 (1 << 0)\n#define ISA_2 (1 << 1)\n#define ISA_3 (1 << 2)\n#define ISA_4 (1 << 3)\n#define ISA_5 (1 << 4)\n\nstruct opcode opcodes[OP_UNUSED + 1] = {\n\t{\n\t\t\"add.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"add.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"add.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"addc\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"and.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"and.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"and.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"asr.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"asr.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"asr.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"bclr\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"bfextu\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"bfrvrs\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"bkpt\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"bset\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"btst\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"call\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"calli\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"cmpi\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"crcgen\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"ext.1\",\n\t\t1,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"ext.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"flush\",\n\t\t4,\n\t\tISA_5\n\t},\n\t{\n\t\t\"iread\",\n\t\t4,\n\t\tISA_1 | ISA_2\n\t},\n\t{\n\t\t\"iwrite\",\n\t\t4,\n\t\tISA_1 | ISA_2\n\t},\n\t{\n\t\t\"jmpf.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplo.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphs.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpeq.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpge.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpgt.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphi.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmple.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpls.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplt.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpmi.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpne.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmppl.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpt.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvc.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvs.s.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpf.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplo.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphs.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpeq.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpge.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpgt.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphi.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmple.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpls.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplt.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpmi.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpne.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmppl.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpt.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvc.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvs.s.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpf.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplo.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphs.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpeq.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpge.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpgt.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphi.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmple.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpls.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplt.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpmi.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpne.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmppl.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpt.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvc.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvs.w.f\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpf.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplo.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphs.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpeq.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpge.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpgt.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmphi.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmple.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpls.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmplt.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpmi.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpne.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmppl.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpt.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvc.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"jmpvs.w.t\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lea.1\",\n\t\t1,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lea.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lea.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lsl.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lsl.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lsl.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lsr.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lsr.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"lsr.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mac\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.2\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.2.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.2.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.2.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.4\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.4.c\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.4.t\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"madd.4.c.t\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macf\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macf.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macf.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macf.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macs\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macs.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macs.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macs.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macu\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macu.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macu.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macu.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macus\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macus.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macus.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"macus.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"merge\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"move.1\",\n\t\t1,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"move.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"move.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"movea\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"moveai\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"movei\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.2\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.2.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.2.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.2.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.4\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.4.c\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.4.t\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msub.4.c.t\",\n\t\t4,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msuf\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msuf.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msuf.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"msuf.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulf\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulf.c\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulf.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulf.c.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"muls\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"muls.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"muls.4\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulu\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulu.t\",\n\t\t2,\n\t\tISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"mulu.4\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"not.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"not.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"or.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"or.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"or.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pdec\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"prefetch\",\n\t\t4,\n\t\tISA_5\n\t},\n\t{\n\t\t\"pxadds\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxadds.u\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxblend\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxblend.t\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxcnv\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxcnv.t\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxhi\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxhi.s\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxvi\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"pxvi.s\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"ret\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"setcsr\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"shiftd\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"shmrg.1\",\n\t\t1,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"shmrg.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"sub.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"sub.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"sub.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"subc\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"suspend\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"swapb.2\",\n\t\t2,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"swapb.4\",\n\t\t4,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"sync\",\n\t\t4,\n\t\tISA_5\n\t},\n\t{\n\t\t\"syscall\",\n\t\t4,\n\t\tISA_5\n\t},\n\t{\n\t\t\"sysret\",\n\t\t4,\n\t\tISA_5\n\t},\n\t{\n\t\t\"xor.1\",\n\t\t1,\n\t\tISA_4 | ISA_5\n\t},\n\t{\n\t\t\"xor.2\",\n\t\t2,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"xor.4\",\n\t\t4,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t},\n\t{\n\t\t\"unused\",\n\t\t0,\n\t\tISA_1 | ISA_2 | ISA_3 | ISA_4 | ISA_5\n\t}\n};\n\n/*\n * Register names.\n */\nconst char regname[0x102][17] = {\n\t\"d0\",\n\t\"d1\",\n\t\"d2\",\n\t\"d3\",\n\t\"d4\",\n\t\"d5\",\n\t\"d6\",\n\t\"d7\",\n\t\"d8\",\n\t\"d9\",\n\t\"d10\",\n\t\"d11\",\n\t\"d12\",\n\t\"d13\",\n\t\"d14\",\n\t\"d15\",\n\t\"reserved_10\",\n\t\"reserved_11\",\n\t\"reserved_12\",\n\t\"reserved_13\",\n\t\"reserved_14\",\n\t\"reserved_15\",\n\t\"reserved_16\",\n\t\"reserved_17\",\n\t\"reserved_18\",\n\t\"reserved_19\",\n\t\"reserved_1a\",\n\t\"reserved_1b\",\n\t\"reserved_1c\",\n\t\"reserved_1d\",\n\t\"reserved_1e\",\n\t\"reserved_1f\",\n\t\"a0\",\n\t\"a1\",\n\t\"a2\",\n\t\"a3\",\n\t\"a4\",\n\t\"a5\",\n\t\"a6\",\n\t\"sp\",\n\t\"acc0_hi\",\n\t\"acc0_lo\",\n\t\"mac_rc16\",\n\t\"source3\",\n\t\"inst_cnt\",\n\t\"csr\",\n\t\"rosr\",\n\t\"iread_data\",\n\t\"int_mask0\",\n\t\"int_mask1\",\n\t\"reserved_32\",\n\t\"reserved_33\",\n\t\"pc\",\n\t\"trap_cause\",\n\t\"acc1_hi\",\n\t\"acc1_lo\",\n\t\"previous_pc\",\n\t\"pcsr\",\n\t\"reserved_3a\",\n\t\"reserved_3b\",\n\t\"reserved_3c\",\n\t\"reserved_3d\",\n\t\"reserved_3e\",\n\t\"reserved_3f\",\n\t\"chip_id\",\n\t\"int_stat0\",\n\t\"int_stat1\",\n\t\"reserved_43\",\n\t\"reserved_44\",\n\t\"int_set0\",\n\t\"int_set1\",\n\t\"reserved_47\",\n\t\"reserved_48\",\n\t\"int_clr0\",\n\t\"int_clr1\",\n\t\"reserved_4b\",\n\t\"reserved_4c\",\n\t\"global_ctrl\",\n\t\"mt_active\",\n\t\"mt_active_set\",\n\t\"mt_active_clr\",\n\t\"mt_dbg_active\",\n\t\"mt_dbg_active_set\",\n\t\"mt_en\",\n\t\"mt_hpri\",\n\t\"mt_hrt\",\n\t\"mt_break\",\n\t\"mt_break_clr\",\n\t\"mt_single_step\",\n\t\"mt_min_delay_en\",\n\t\"mt_break_set\",\n\t\"perr_addr\",\n\t\"dcapt\",\n\t\"dcapt_pc\",\n\t\"dcapt_tnum\",\n\t\"mt_dbg_active_clr\",\n\t\"scratchpad0\",\n\t\"scratchpad1\",\n\t\"scratchpad2\",\n\t\"scratchpad3\",\n\t\"reserved_64\",\n\t\"reserved_65\",\n\t\"reserved_66\",\n\t\"reserved_67\",\n\t\"cfg\",\n\t\"reserved_69\",\n\t\"reserved_6a\",\n\t\"reserved_6b\",\n\t\"reserved_6c\",\n\t\"reserved_6d\",\n\t\"mt_trap_en\",\n\t\"mt_trap\",\n\t\"mt_trap_set\",\n\t\"mt_trap_clr\",\n\t\"sep\",\n\t\"reserved_73\",\n\t\"reserved_74\",\n\t\"reserved_75\",\n\t\"reserved_76\",\n\t\"reserved_77\",\n\t\"reserved_78\",\n\t\"reserved_79\",\n\t\"reserved_7a\",\n\t\"reserved_7b\",\n\t\"reserved_7c\",\n\t\"reserved_7d\",\n\t\"reserved_7e\",\n\t\"reserved_7f\",\n\t\"reserved_80\",\n\t\"reserved_81\",\n\t\"reserved_82\",\n\t\"reserved_83\",\n\t\"reserved_84\",\n\t\"reserved_85\",\n\t\"reserved_86\",\n\t\"reserved_87\",\n\t\"reserved_88\",\n\t\"reserved_89\",\n\t\"reserved_8a\",\n\t\"reserved_8b\",\n\t\"reserved_8c\",\n\t\"reserved_8d\",\n\t\"reserved_8e\",\n\t\"reserved_8f\",\n\t\"reserved_90\",\n\t\"reserved_91\",\n\t\"reserved_92\",\n\t\"reserved_93\",\n\t\"reserved_94\",\n\t\"reserved_95\",\n\t\"reserved_96\",\n\t\"reserved_97\",\n\t\"reserved_98\",\n\t\"reserved_99\",\n\t\"reserved_9a\",\n\t\"reserved_9b\",\n\t\"reserved_9c\",\n\t\"reserved_9d\",\n\t\"reserved_9e\",\n\t\"reserved_9f\",\n\t\"reserved_a0\",\n\t\"reserved_a1\",\n\t\"reserved_a2\",\n\t\"reserved_a3\",\n\t\"reserved_a4\",\n\t\"reserved_a5\",\n\t\"reserved_a6\",\n\t\"reserved_a7\",\n\t\"reserved_a8\",\n\t\"reserved_a9\",\n\t\"reserved_aa\",\n\t\"reserved_ab\",\n\t\"reserved_ac\",\n\t\"reserved_ad\",\n\t\"reserved_ae\",\n\t\"reserved_af\",\n\t\"reserved_b0\",\n\t\"reserved_b1\",\n\t\"reserved_b2\",\n\t\"reserved_b3\",\n\t\"reserved_b4\",\n\t\"reserved_b5\",\n\t\"reserved_b6\",\n\t\"reserved_b7\",\n\t\"reserved_b8\",\n\t\"reserved_b9\",\n\t\"reserved_ba\",\n\t\"reserved_bb\",\n\t\"reserved_bc\",\n\t\"reserved_bd\",\n\t\"reserved_be\",\n\t\"reserved_bf\",\n\t\"reserved_c0\",\n\t\"reserved_c1\",\n\t\"reserved_c2\",\n\t\"reserved_c3\",\n\t\"reserved_c4\",\n\t\"reserved_c5\",\n\t\"reserved_c6\",\n\t\"reserved_c7\",\n\t\"reserved_c8\",\n\t\"reserved_c9\",\n\t\"reserved_ca\",\n\t\"reserved_cb\",\n\t\"reserved_cc\",\n\t\"reserved_cd\",\n\t\"reserved_ce\",\n\t\"reserved_cf\",\n\t\"reserved_d0\",\n\t\"reserved_d1\",\n\t\"reserved_d2\",\n\t\"reserved_d3\",\n\t\"reserved_d4\",\n\t\"reserved_d5\",\n\t\"reserved_d6\",\n\t\"reserved_d7\",\n\t\"reserved_d8\",\n\t\"reserved_d9\",\n\t\"reserved_da\",\n\t\"reserved_db\",\n\t\"reserved_dc\",\n\t\"reserved_dd\",\n\t\"reserved_de\",\n\t\"reserved_df\",\n\t\"reserved_e0\",\n\t\"reserved_e1\",\n\t\"reserved_e2\",\n\t\"reserved_e3\",\n\t\"reserved_e4\",\n\t\"reserved_e5\",\n\t\"reserved_e6\",\n\t\"reserved_e7\",\n\t\"reserved_e8\",\n\t\"reserved_e9\",\n\t\"reserved_ea\",\n\t\"reserved_eb\",\n\t\"reserved_ec\",\n\t\"reserved_ed\",\n\t\"reserved_ee\",\n\t\"reserved_ef\",\n\t\"reserved_f0\",\n\t\"reserved_f1\",\n\t\"reserved_f2\",\n\t\"reserved_f3\",\n\t\"reserved_f4\",\n\t\"reserved_f5\",\n\t\"reserved_f6\",\n\t\"reserved_f7\",\n\t\"reserved_f8\",\n\t\"reserved_f9\",\n\t\"reserved_fa\",\n\t\"reserved_fb\",\n\t\"reserved_fc\",\n\t\"reserved_fd\",\n\t\"reserved_fe\",\n\t\"reserved_ff\",\n\t\"acc0\",\n\t\"acc1\"\n};\n\n/*\n * Element types.\n */\nenum element_type {\n\tET_OPCODE,\n\tET_LABEL,\n\tET_BLOCK_SEPARATOR,\n\tET_SECTION,\n\tET_SYMBOL\n};\n\n/*\n * code element.\n *\tBase structure type used for code sequences.\n *\n * This is effectively a base class from which can be derived a number\n * of concrete classes.  The key aspect of this base class is that is\n * allows efficient representation of the derived classes and allows\n * the various subclasses to be linked together into a single list.\n */\nstruct code_element {\n\tenum element_type type;\t\t\t/* What type of element is this? */\n\tstruct code_element *prev;\t\t/* Previous code element */\n\tstruct code_element *next;\t\t/* Next code element */\n};\n\n/*\n * Label element.\n *\tThis represents a single label annotation.\n */\nstruct code_element_label {\n\tstruct code_element ce;\t\t\t/* Base class - must be first in the structure */\n\tuint32_t addr;\t\t\t\t/* Address */\n\tint refs;\t\t\t\t/* Number of references to this label */\n\tint number;\t\t\t\t/* Label number */\n\tbool call_label;\t\t\t/* Is this a call target? */\n\tstruct code_element_label *hash_next;\t/* Next label in hash */\n\tchar *name;\t\t\t\t/* Name associated with this label */\n};\n\n/*\n * Block separator element.\n *\tThis represents a single basic block separator annotation.\n */\nstruct code_element_block_separator {\n\tstruct code_element ce;\t\t\t/* Base class - must be first in the structure */\n};\n\n/*\n * Section element.\n *\tThis represents the start of a section.\n */\nstruct code_element_section {\n\tstruct code_element ce;\t\t\t/* Base class - must be first in the structure */\n\tchar *name;\t\t\t\t/* Section name */\n\tint number;\t\t\t\t/* Section number */\n\tstruct code_element_section *hash_next;\t/* Next section in hash */\n};\n\n/*\n * Symbol element.\n *\tThis represents a single symbol table annotation.\n */\nstruct code_element_symbol {\n\tstruct code_element ce;\t\t\t/* Base class - must be first in the structure */\n\tuint32_t addr;\t\t\t\t/* Address */\n\tuint32_t str_offs;\t\t\t/* Offset into strings section for the name */\n\tchar *name;\t\t\t\t/* Symbol name */\n\tint type;\t\t\t\t/* Symbol type */\n\tint section;\t\t\t\t/* Symbol section */\n};\n\n/*\n * Operand modes.\n */\nenum operand_mode {\n\tOM_AREG_PLUS_IMM,\n\tOM_AREG_PLUS_DREG,\n\tOM_AREG_MODIFY,\n\tOM_REG,\n\tOM_IMM,\n\tOM_UNUSED\n};\n\n/*\n * Operand encodings.\n */\nstruct operand_areg_plus_imm {\n\tint areg;\n\tint imm;\n};\n\nstruct operand_areg_plus_dreg {\n\tint areg;\n\tint dreg;\n};\n\nstruct operand_areg_modify {\n\tint areg;\n\tint modify;\n};\n\nstruct operand_reg {\n\tint reg;\n};\n\nstruct operand_imm {\n\tint imm;\n};\n\n/*\n * Operand.\n */\nstruct operand {\n\tenum operand_mode mode;\n\tunion {\n\t\tstruct operand_areg_plus_imm oapi;\n\t\tstruct operand_areg_plus_dreg oapd;\n\t\tstruct operand_areg_modify oam;\n\t\tstruct operand_reg or;\n\t\tstruct operand_imm oi;\n\t} value;\n};\n\n/*\n * Opcode element.\n *\tThis represents a single Dalvik opcode.\n */\nstruct code_element_opcode {\n\tstruct code_element ce;\t\t\t/* Base class - must be first in the structure */\n\tuint32_t instr;\t\t\t\t/* Actual instruction word */\n\tuint32_t addr;\t\t\t\t/* Address */\n\tenum opcodes opcode;\t\t\t/* Opcode */\n\tstruct operand src1;\n\tstruct operand src2;\n\tstruct operand dest;\n\tstruct code_element_label *label;\t/* Any label we reference */\n};\n\n#define LABEL_HASH_SLOTS 256\t\t\t/* Number of slots in the label hash table */\n#define SECTION_HASH_SLOTS 256\t\t\t/* Number of slots in the section hash table */\n\nstruct elf32_hdr *elf_hdr;\nstruct code_element *code_head;\nstruct code_element *code_tail;\nstruct code_element_label *label_hash[LABEL_HASH_SLOTS];\nstruct code_element_section *section_hash[SECTION_HASH_SLOTS];\nint opcode_counts[OP_UNUSED + 1];\nint isa_version = 4;\t\t\t\t// XXX - not really true - need to autodetect\nint total_insns;\nchar *elf_shstrings;\nchar *elf_strings;\nint symtab_section;\t\t\t\t/* Symbol table section number */\nint dynsym_section;\t\t\t\t/* Dynamic symbol table section number */\n\n/*\n * elf_uint16_to_host()\n *\tConvert 16-bit value from the form in the ELF file to the form required for the host.\n */\nuint16_t elf_uint16_to_host(uint16_t v)\n{\n\tif (elf_hdr->e_ident[EI_DATA] == ELFDATA2MSB) {\n\t\treturn htons(v);\n\t}\n\n\treturn v;\n}\n\n/*\n * elf_uint32_to_host()\n *\tConvert 32-bit value from the form in the ELF file to the form required for the host.\n */\nuint32_t elf_uint32_to_host(uint32_t v)\n{\n\tif (elf_hdr->e_ident[EI_DATA] == ELFDATA2MSB) {\n\t\treturn htonl(v);\n\t}\n\n\treturn v;\n}\n\n/*\n * decode_general_operand()\n */\nstatic void decode_general_operand(struct operand *operand, uint32_t op)\n{\n\tif (op & 0x400) {\n\t\toperand->mode = OM_AREG_PLUS_IMM;\n\t\toperand->value.oapi.areg = 0x20 + ((op >> 5) & 0x7);\n\t\toperand->value.oapi.imm = (op & 0x1f) | ((op & 0x300) >> 3);\n\t\treturn;\n\t}\n\n\tswitch ((op & 0x300) >> 8) {\n\tcase 0:\n\t\toperand->mode = OM_IMM;\n\t\toperand->value.oi.imm = (int8_t)(op & 0xff);\n\t\tbreak;\n\n\tcase 1:\n\t\toperand->mode = OM_REG;\n\t\toperand->value.or.reg = op & 0xff;\n\t\tbreak;\n\n\tcase 2:\n\t\toperand->mode = OM_AREG_MODIFY;\n\t\toperand->value.oam.areg = 0x20 + ((op >> 5) & 0x7);\n\t\toperand->value.oam.modify = op & 0x1f;\n\t\tbreak;\n\n\tcase 3:\n\t\toperand->mode = OM_AREG_PLUS_DREG;\n\t\toperand->value.oapd.areg = 0x20 + ((op >> 5) & 0x7);\n\t\toperand->value.oapd.dreg = op & 0xf;\n\t}\n}\n\n/*\n * decode_imm_operand()\n */\nstatic void decode_imm_operand(struct operand *operand, int imm)\n{\n\toperand->mode = OM_IMM;\n\toperand->value.oi.imm = imm;\n}\n\n/*\n * decode_dreg_operand()\n */\nstatic void decode_reg_operand(struct operand *operand, int reg)\n{\n\toperand->mode = OM_REG;\n\toperand->value.or.reg = reg;\n}\n\n/*\n * decode_insn_format_1()\n */\nstatic void decode_insn_format_1(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_general_operand(&ceo->dest, (op >> 16) & 0x7ff);\n\tdecode_general_operand(&ceo->src1, op & 0x7ff);\n\n\tint ext = (op >> 11) & 0x1f;\n\tswitch (ext) {\n\tcase 0x01:\n\t\tceo->opcode = OP_SUSPEND;\n\t\tbreak;\n\n\tcase 0x02:\n\t\tceo->opcode = OP_FLUSH;\n\t\tbreak;\n\n\tcase 0x03:\n\t\tceo->opcode = OP_SYNC;\n\t\tbreak;\n\n\tcase 0x04:\n\t\tceo->opcode = OP_RET;\n\t\tbreak;\n\n\tcase 0x05:\n\t\tceo->opcode = OP_PREFETCH;\n\t\tbreak;\n\n\tcase 0x06:\n\t\tceo->opcode = OP_IREAD;\n\t\tbreak;\n\n\tcase 0x07:\n\t\tceo->opcode = OP_BKPT;\n\t\tbreak;\n\n\tcase 0x08:\n\t\tceo->opcode = OP_SYSRET;\n\t\tbreak;\n\n\tcase 0x09:\n\t\tceo->opcode = OP_SYSCALL;\n\t\tbreak;\n\n\tcase 0x0a:\n\t\tceo->opcode = OP_NOT_4;\n\t\tbreak;\n\n\tcase 0x0b:\n\t\tceo->opcode = OP_NOT_2;\n\t\tbreak;\n\n\tcase 0x0c:\n\t\tceo->opcode = OP_MOVE_4;\n\t\tbreak;\n\n\tcase 0x0d:\n\t\tceo->opcode = OP_MOVE_2;\n\t\tbreak;\n\n\tcase 0x0e:\n\t\tceo->opcode = OP_MOVEA;\n\t\tbreak;\n\n\tcase 0x0f:\n\t\tceo->opcode = OP_MOVE_1;\n\t\tbreak;\n\n\tcase 0x10:\n\t\tceo->opcode = OP_IWRITE;\n\t\tbreak;\n\n\tcase 0x12:\n\t\tceo->opcode = OP_SETCSR;\n\t\tbreak;\n\n\tcase 0x15:\n\t\tceo->opcode = OP_EXT_2;\n\t\tbreak;\n\n\tcase 0x17:\n\t\tceo->opcode = OP_EXT_1;\n\t\tbreak;\n\n\tcase 0x18:\n\t\tceo->opcode = OP_SWAPB_2;\n\t\tbreak;\n\n\tcase 0x19:\n\t\tceo->opcode = OP_SWAPB_4;\n\t\tbreak;\n\n\tcase 0x1a:\n\t\tceo->opcode = OP_PXCNV;\n\t\tbreak;\n\n\tcase 0x1b:\n\t\tceo->opcode = OP_PXCNV_T;\n\t\tbreak;\n\n\tcase 0x1c:\n\t\tceo->opcode = OP_LEA_4;\n\t\tbreak;\n\n\tcase 0x1d:\n\t\tceo->opcode = OP_LEA_2;\n\t\tbreak;\n\n\tcase 0x1e:\n\t\tceo->opcode = OP_PDEC;\n\t\tbreak;\n\n\tcase 0x1f:\n\t\tceo->opcode = OP_LEA_1;\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * decode_insn_format_2()\n */\nstatic void decode_insn_format_2(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_general_operand(&ceo->dest, (op >> 16) & 0x7ff);\n\tdecode_general_operand(&ceo->src1, op & 0x7ff);\n\tdecode_imm_operand(&ceo->src2, (op >> 11) & 0x1f);\n\n\tswitch ((op >> 27) & 0x1f) {\n\tcase 0x04:\n\t\tceo->opcode = OP_BSET;\n\t\tbreak;\n\n\tcase 0x05:\n\t\tceo->opcode = OP_BCLR;\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * decode_insn_format_3()\n */\nstatic void decode_insn_format_3(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_general_operand(&ceo->dest, (op >> 16) & 0x7ff);\n\tdecode_general_operand(&ceo->src1, op & 0x7ff);\n\tdecode_reg_operand(&ceo->src2, (op >> 11) & 0xf);\n\n\tswitch ((op >> 27) & 0x1f) {\n\tcase 0x08:\n\t\tceo->opcode = (op & 0x8000) ? OP_AND_1 : OP_AND_2;\n\t\tbreak;\n\n\tcase 0x09:\n\t\tceo->opcode = OP_AND_4;\n\t\tbreak;\n\n\tcase 0x0a:\n\t\tceo->opcode = (op & 0x8000) ? OP_OR_1 : OP_OR_2;\n\t\tbreak;\n\n\tcase 0x0b:\n\t\tceo->opcode = OP_OR_4;\n\t\tbreak;\n\n\tcase 0x0c:\n\t\tceo->opcode = (op & 0x8000) ? OP_XOR_1 : OP_XOR_2;\n\t\tbreak;\n\n\tcase 0x0d:\n\t\tceo->opcode = OP_XOR_4;\n\t\tbreak;\n\n\tcase 0x0e:\n\t\tceo->opcode = (op & 0x8000) ? OP_ADD_1 : OP_ADD_2;\n\t\tbreak;\n\n\tcase 0x0f:\n\t\tceo->opcode = OP_ADD_4;\n\t\tbreak;\n\n\tcase 0x10:\n\t\tceo->opcode = OP_ADDC;\n\t\tbreak;\n\n\tcase 0x11:\n\t\tceo->opcode = (op & 0x8000) ? OP_SUB_1 : OP_SUB_2;\n\t\tbreak;\n\n\tcase 0x12:\n\t\tceo->opcode = OP_SUB_4;\n\t\tbreak;\n\n\tcase 0x13:\n\t\tceo->opcode = OP_SUBC;\n\t\tbreak;\n\n\tcase 0x14:\n\t\tceo->opcode = (op & 0x8000) ? OP_PXBLEND_T : OP_PXBLEND;\n\t\tbreak;\n\n\tcase 0x15:\n\t\tceo->opcode = (op & 0x8000) ? OP_PXVI_S : OP_PXVI;\n\t\tbreak;\n\n\tcase 0x16:\n\t\tceo->opcode = (op & 0x8000) ? OP_PXADDS_U : OP_PXADDS;\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * decode_insn_format_4()\n */\nstatic void decode_insn_format_4(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_reg_operand(&ceo->dest, (op >> 16) & 0xf);\n\tdecode_general_operand(&ceo->src1, op & 0x7ff);\n\tif (op & 0x04000000) {\n\t\tdecode_reg_operand(&ceo->src2, (op >> 11) & 0xf);\n\t} else {\n\t\tdecode_imm_operand(&ceo->src2, (op >> 11) & 0x1f);\n\t}\n\n\tint ext = (op >> 21) & 0x1f;\n\tswitch (ext) {\n\tcase 0x00:\n\t\tceo->opcode = OP_PXHI;\n\t\tbreak;\n\n\tcase 0x01:\n\t\tceo->opcode = OP_MULS;\n\t\tbreak;\n\n\tcase 0x02:\n\t\tceo->opcode = OP_PXHI_S;\n\t\tbreak;\n\n\tcase 0x03:\n\t\tceo->opcode = OP_MULU;\n\t\tbreak;\n\n\tcase 0x05:\n\t\tceo->opcode = OP_MULF;\n\t\tbreak;\n\n\tcase 0x06:\n\t\tceo->opcode = OP_BTST;\n\t\tbreak;\n\n\tcase 0x08:\n\t\tceo->opcode = OP_CRCGEN;\n\t\tbreak;\n\n\tcase 0x09:\n\t\tceo->opcode = OP_MAC;\n\t\tbreak;\n\n\tcase 0x0a:\n\t\tceo->opcode = OP_LSL_1;\n\t\tbreak;\n\n\tcase 0x0b:\n\t\tceo->opcode = OP_LSR_1;\n\t\tbreak;\n\n\tcase 0x0c:\n\t\tceo->opcode = OP_ASR_1;\n\t\tbreak;\n\n\tcase 0x10:\n\t\tceo->opcode = OP_LSL_4;\n\t\tbreak;\n\n\tcase 0x11:\n\t\tceo->opcode = OP_LSL_2;\n\t\tbreak;\n\n\tcase 0x12:\n\t\tceo->opcode = OP_LSR_4;\n\t\tbreak;\n\n\tcase 0x13:\n\t\tceo->opcode = OP_LSR_2;\n\t\tbreak;\n\n\tcase 0x14:\n\t\tceo->opcode = OP_ASR_4;\n\t\tbreak;\n\n\tcase 0x15:\n\t\tceo->opcode = OP_ASR_2;\n\t\tbreak;\n\n\tcase 0x16:\n\t\tceo->opcode = OP_BFEXTU;\n\t\tbreak;\n\n\tcase 0x18:\n\t\tceo->opcode = OP_BFRVRS;\n\t\tbreak;\n\n\tcase 0x1a:\n\t\tceo->opcode = OP_SHFTD;\n\t\tbreak;\n\n\tcase 0x1c:\n\t\tceo->opcode = OP_MERGE;\n\t\tbreak;\n\n\tcase 0x1e:\n\t\tceo->opcode = OP_SHMRG_2;\n\t\tbreak;\n\n\tcase 0x1f:\n\t\tceo->opcode = OP_SHMRG_1;\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * decode_insn_format_5()\n */\nstatic void decode_insn_format_5(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_general_operand(&ceo->src1, op & 0x7ff);\n\tdecode_imm_operand(&ceo->src2, (op >> 11) & 0xffff);\n\n\tceo->opcode = OP_CMPI;\n}\n\n/*\n * decode_insn_format_6()\n */\nstatic void decode_insn_format_6(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_general_operand(&ceo->dest, (op >> 16) & 0x7ff);\n\tdecode_imm_operand(&ceo->src1, (int16_t)(op & 0xffff));\n\n\tceo->opcode = OP_MOVEI;\n}\n\nstatic enum opcodes jmp_ops[64] = {\n\tOP_JMPF_S_F,\n\tOP_JMPF_W_F,\n\tOP_JMPF_S_T,\n\tOP_JMPF_W_T,\n\tOP_JMPLO_S_F,\n\tOP_JMPLO_W_F,\n\tOP_JMPLO_S_T,\n\tOP_JMPLO_W_T,\n\tOP_JMPHS_S_F,\n\tOP_JMPHS_W_F,\n\tOP_JMPHS_S_T,\n\tOP_JMPHS_W_T,\n\tOP_JMPEQ_S_F,\n\tOP_JMPEQ_W_F,\n\tOP_JMPEQ_S_T,\n\tOP_JMPEQ_W_T,\n\tOP_JMPGE_S_F,\n\tOP_JMPGE_W_F,\n\tOP_JMPGE_S_T,\n\tOP_JMPGE_W_T,\n\tOP_JMPGT_S_F,\n\tOP_JMPGT_W_F,\n\tOP_JMPGT_S_T,\n\tOP_JMPGT_W_T,\n\tOP_JMPHI_S_F,\n\tOP_JMPHI_W_F,\n\tOP_JMPHI_S_T,\n\tOP_JMPHI_W_T,\n\tOP_JMPLE_S_F,\n\tOP_JMPLE_W_F,\n\tOP_JMPLE_S_T,\n\tOP_JMPLE_W_T,\n\tOP_JMPLS_S_F,\n\tOP_JMPLS_W_F,\n\tOP_JMPLS_S_T,\n\tOP_JMPLS_W_T,\n\tOP_JMPLT_S_F,\n\tOP_JMPLT_W_F,\n\tOP_JMPLT_S_T,\n\tOP_JMPLT_W_T,\n\tOP_JMPMI_S_F,\n\tOP_JMPMI_W_F,\n\tOP_JMPMI_S_T,\n\tOP_JMPMI_W_T,\n\tOP_JMPNE_S_F,\n\tOP_JMPNE_W_F,\n\tOP_JMPNE_S_T,\n\tOP_JMPNE_W_T,\n\tOP_JMPPL_S_F,\n\tOP_JMPPL_W_F,\n\tOP_JMPPL_S_T,\n\tOP_JMPPL_W_T,\n\tOP_JMPT_S_F,\n\tOP_JMPT_W_F,\n\tOP_JMPT_S_T,\n\tOP_JMPT_W_T,\n\tOP_JMPVC_S_F,\n\tOP_JMPVC_W_F,\n\tOP_JMPVC_S_T,\n\tOP_JMPVC_W_T,\n\tOP_JMPVS_S_F,\n\tOP_JMPVS_W_F,\n\tOP_JMPVS_S_T,\n\tOP_JMPVS_W_T\n};\n\n/*\n * decode_insn_format_7()\n */\nstatic void decode_insn_format_7(struct code_element_opcode *ceo, uint32_t op)\n{\n\tint ival = op & 0x100000 ? -1 : 0;\n\tival &= (~0xfffff);\n\tival |= op & 0xfffff;\n\tdecode_imm_operand(&ceo->src1, ival);\n\n\tceo->opcode = jmp_ops[(op >> 21) & 0x3f];\n}\n\n/*\n * decode_insn_format_8()\n */\nstatic void decode_insn_format_8(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_reg_operand(&ceo->dest, ((op & 0x00e00000) >> 21) + 32);\n\tdecode_imm_operand(&ceo->src1, op & 0x1fffff | ((op & 0x07000000) >> 3));\n\n\tswitch ((op >> 27) & 0x1f) {\n\tcase 0x1b:\n\t\t{\n\t\t\tint ival = ceo->src1.value.oi.imm & 0x800000 ? -1 : 0;\n\t\t\tival &= (~0x7fffff);\n\t\t\tceo->src1.value.oi.imm = ival | ceo->src1.value.oi.imm & 0x7fffff;\n\t\t\tceo->opcode = OP_CALL;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1c:\n\t\tceo->opcode = OP_MOVEAI;\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * decode_insn_format_9()\n */\nstatic void decode_insn_format_9(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_reg_operand(&ceo->dest, ((op & 0x00e00000) >> 21) + 32);\n\tstruct operand *operand = &ceo->src1;\n\toperand->mode = OM_AREG_PLUS_IMM;\n\toperand->value.oapi.areg = 0x20 + ((op >> 5) & 0x7);\n\toperand->value.oapi.imm = (op & 0x1f) | ((op >> 3) & 0xe0) | ((op >> 8) & 0x1f00) | ((op >> 11) & 0xe000);\n\n\tceo->opcode = OP_CALLI;\n}\n\n/*\n * decode_insn_format_10()\n */\nstatic void decode_insn_format_10(struct code_element_opcode *ceo, uint32_t op)\n{\n\tdecode_reg_operand(&ceo->dest, (op & 0x10000) ? 0x101 : 0x100);\n\tdecode_general_operand(&ceo->src1, op & 0x7ff);\n\tdecode_reg_operand(&ceo->src2, (op >> 11) & 0xf);\n\tif (op & 0x04000000) {\n\t\tdecode_reg_operand(&ceo->src2, (op >> 11) & 0xf);\n\t} else {\n\t\tdecode_imm_operand(&ceo->src2, (op >> 11) & 0x1f);\n\t}\n\n\tint ext = (op >> 21) & 0x1f;\n\tswitch (ext) {\n\tcase 0x00:\n\t\tceo->opcode = (op & 0x80000) ? OP_MULS_T : OP_MULS;\n\t\tbreak;\n\n\tcase 0x01:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MACS_C_T : OP_MACS_C) :\n\t\t\t\t((op & 0x80000) ? OP_MACS_T : OP_MACS);\n\t\tbreak;\n\n\tcase 0x02:\n\t\tceo->opcode = (op & 0x80000) ? OP_MULU_T : OP_MULU;\n\t\tbreak;\n\n\tcase 0x03:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MACU_C_T : OP_MACU_C) :\n\t\t\t\t((op & 0x80000) ? OP_MACU_T : OP_MACU);\n\t\tbreak;\n\n\tcase 0x04:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MULF_C_T : OP_MULF_C) :\n\t\t\t\t((op & 0x80000) ? OP_MULF_T : OP_MULF);\n\t\tbreak;\n\n\tcase 0x05:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MACF_C_T : OP_MACF_C) :\n\t\t\t\t((op & 0x80000) ? OP_MACF_T : OP_MACF);\n\t\tbreak;\n\n\tcase 0x07:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MACUS_C_T : OP_MACUS_C) :\n\t\t\t\t((op & 0x80000) ? OP_MACUS_T : OP_MACUS);\n\t\tbreak;\n\n\tcase 0x08:\n\t\tceo->opcode = OP_MULS_4;\n\t\tbreak;\n\n\tcase 0x09:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MSUF_C_T : OP_MSUF_C) :\n\t\t\t\t((op & 0x80000) ? OP_MSUF_T : OP_MSUF);\n\t\tbreak;\n\n\tcase 0x0a:\n\t\tceo->opcode = OP_MULU_4;\n\t\tbreak;\n\n\tcase 0x10:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MADD_4_C_T : OP_MADD_4_C) :\n\t\t\t\t((op & 0x80000) ? OP_MADD_4_T : OP_MADD_4);\n\t\tbreak;\n\n\tcase 0x11:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MADD_2_C_T : OP_MADD_2_C) :\n\t\t\t\t((op & 0x80000) ? OP_MADD_2_T : OP_MADD_2);\n\t\tbreak;\n\n\tcase 0x12:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MSUB_4_C_T : OP_MSUB_4_C) :\n\t\t\t\t((op & 0x80000) ? OP_MSUB_4_T : OP_MSUB_4);\n\t\tbreak;\n\n\tcase 0x13:\n\t\tceo->opcode = (op & 0x100000) ?\n\t\t\t\t((op & 0x80000) ? OP_MSUB_2_C_T : OP_MSUB_2_C) :\n\t\t\t\t((op & 0x80000) ? OP_MSUB_2_T : OP_MSUB_2);\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * decode_insn()\n */\nstatic void decode_insn(struct code_element_opcode *ceo)\n{\n\tuint32_t op = ceo->instr;\n\n\t/*\n\t * Split into opcode formats.\n\t */\n\tint op_group = op >> 27;\n\tswitch (op_group) {\n\tcase 0x00:\n\t\tdecode_insn_format_1(ceo, op);\n\t\tbreak;\n\n\tcase 0x04:\n\tcase 0x05:\n\t\tdecode_insn_format_2(ceo, op);\n\t\tbreak;\n\n\tcase 0x08:\n\tcase 0x09:\n\tcase 0x0a:\n\tcase 0x0b:\n\tcase 0x0c:\n\tcase 0x0d:\n\tcase 0x0e:\n\tcase 0x0f:\n\tcase 0x10:\n\tcase 0x11:\n\tcase 0x12:\n\tcase 0x13:\n\tcase 0x14:\n\tcase 0x15:\n\tcase 0x16:\n\t\tdecode_insn_format_3(ceo, op);\n\t\tbreak;\n\n\tcase 0x02:\n\t\tdecode_insn_format_4(ceo, op);\n\t\tbreak;\n\n\tcase 0x18:\n\t\tdecode_insn_format_5(ceo, op);\n\t\tbreak;\n\n\tcase 0x19:\n\t\tdecode_insn_format_6(ceo, op);\n\t\tbreak;\n\n\tcase 0x1a:\n\t\tdecode_insn_format_7(ceo, op);\n\t\tbreak;\n\n\tcase 0x1b:\n\tcase 0x1c:\n\t\tdecode_insn_format_8(ceo, op);\n\t\tbreak;\n\n\tcase 0x1e:\n\t\tdecode_insn_format_9(ceo, op);\n\t\tbreak;\n\n\tcase 0x06:\n\t\tdecode_insn_format_10(ceo, op);\n\t\tbreak;\n\n\tdefault:\n\t\tceo->opcode = OP_UNUSED;\n\t}\n}\n\n/*\n * insert_block_separator_after()\n */\nstatic struct code_element_block_separator *insert_block_separator_after(struct code_element *ce)\n{\n\tstruct code_element_block_separator *b\n\t\t= (struct code_element_block_separator *)malloc(sizeof(struct code_element_block_separator));\n\tif (!b) {\n\t\tfprintf(stderr, \"unable to allocate block separator\\n\");\n\t\treturn NULL;\n\t}\n\n\tb->ce.type = ET_BLOCK_SEPARATOR;\n\n\t/*\n\t * Link ourselves into the stream.  Note that we can never be the head or tail of the\n\t * code element stream so we can do this very simply!\n\t */\n\tb->ce.next = ce->next;\n\tb->ce.prev = ce;\n\tce->next->prev = &b->ce;\n\tce->next = &b->ce;\n\n\treturn b;\n}\n\n/*\n * compute_label()\n */\nstatic struct code_element_label *compute_label(struct code_element_opcode *ceo, int offset, bool call_label)\n{\n\tstruct code_element *ce = (struct code_element *)ceo;\n\tstruct code_element *d = ce;\n\tuint32_t addr = ceo->addr + offset;\n\n\t/*\n\t * First look to see if we already have a label in the label hash.\n\t */\n\tint hash_idx = (addr >> 2) & (LABEL_HASH_SLOTS - 1);\n\tstruct code_element_label *lhash = label_hash[hash_idx];\n\twhile (lhash) {\n\t\tif (lhash->addr == addr) {\n\t\t\tlhash->refs++;\n\t\t\tceo->label = lhash;\n\t\t\treturn lhash;\n\t\t}\n\n\t\tlhash = lhash->hash_next;\n\t}\n\n\t/*\n\t * If the offset is negative walk backwards.\n\t */\n\tif (offset < 0) {\n\t\tuint32_t daddr = 0xfffffffc;\n\t\tdo {\n\t\t\td = d->prev;\n\t\t\tif (d && d->type == ET_OPCODE) {\n\t\t\t\tstruct code_element_opcode *dceo = (struct code_element_opcode *)d;\n\t\t\t\tdaddr = dceo->addr;\n\t\t\t}\n\t\t} while (d && (daddr != addr));\n\n\t\tif ((!d) || (daddr != addr)) {\n\t\t\tfprintf(stderr, \"could not compute label: %lx\\n\", (unsigned long)ce);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (offset > 0) {\n\t\tuint32_t daddr = 0;\n\t\tdo {\n\t\t\td = d->next;\n\t\t\tif (d && d->type == ET_OPCODE) {\n\t\t\t\tstruct code_element_opcode *dceo = (struct code_element_opcode *)d;\n\t\t\t\tdaddr = dceo->addr;\n\t\t\t}\n\t\t} while (d && (daddr != addr));\n\n\t\tif ((!d) || (daddr != addr)) {\n\t\t\tfprintf(stderr, \"could not compute label: %lx\\n\", (unsigned long)ce);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Create and insert the new label.\n\t */\n\tstruct code_element_label *label\n\t\t= (struct code_element_label *)malloc(sizeof(struct code_element_label));\n\tif (!label) {\n\t\tfprintf(stderr, \"unable to allocate label\\n\");\n\t\treturn NULL;\n\t}\n\n\tlabel->ce.type = ET_LABEL;\n\tlabel->addr = addr;\n\tlabel->refs = 1;\n\tlabel->ce.next = d;\n\tlabel->ce.prev = d->prev;\n\tlabel->call_label = call_label;\n\tif (d->prev) {\n\t\td->prev->next = &label->ce;\n\t}\n\td->prev = &label->ce;\n\n\t/*\n\t * Insert ourself into the label hash.\n\t */\n\tlabel->hash_next = label_hash[hash_idx];\n\tlabel_hash[hash_idx] = label;\n\tceo->label = label;\n\n\treturn label;\n}\n\n/*\n * insert_labels_and_separators()\n */\nstatic bool insert_labels_and_separators(void)\n{\n\t/*\n\t * Walk the instruction stream, inserting jump labels and block separators.\n\t */\n\tstruct code_element *ce = code_head->next;\n\twhile (ce != code_tail) {\n\t\tif (ce->type == ET_OPCODE) {\n\t\t\tstruct code_element_opcode *ceo = (struct code_element_opcode *)ce;\n\t\t\tenum opcodes o = ceo->opcode;\n\n\t\t\t/*\n\t\t\t * Look to see if we have an instruction with a label reference.  If we do then\n\t\t\t * try to insert that label.\n\t\t\t */\n\t\t\tif ((o == OP_CALL) || (o >= OP_JMPF_S_F && o <= OP_JMPVS_W_T)) {\n\t\t\t\tstruct code_element_label *label\n\t\t\t\t\t= compute_label(ceo, ceo->src1.value.oi.imm * 4, o == OP_CALL);\n#if 0\n\t\t\t\tif (!label) {\n\t\t\t\t\tfprintf(stderr, \"failed to compute label for opcode: 0x%02x\\n\", o);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Does our instruction terminate a basic block?  If yes then insert a separator.\n\t\t\t */\n\t\t\tif ((o >= OP_JMPF_S_F && o <= OP_JMPVS_W_T)\n\t\t\t\t\t|| o == OP_RET\n\t\t\t\t\t|| o == OP_CALL\n\t\t\t\t\t|| o == OP_CALLI\n\t\t\t\t\t|| o == OP_SYSCALL\n\t\t\t\t\t|| o == OP_SYSRET) {\n\t\t\t\tif (ceo->ce.next) {\n\t\t\t\t\tif (!insert_block_separator_after(&ceo->ce)) {\n\t\t\t\t\t\tfprintf(stderr, \"failed to insert block separator\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Ensure we skip the block separator we just inserted.\n\t\t\t\t\t */\n\t\t\t\t\tce = ce->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tce = ce->next;\n\t}\n\n\treturn true;\n}\n\n/*\n * number_labels()\n */\nstatic bool number_labels(void)\n{\n\tint lnum = 1;\n\n\t/*\n\t * Walk the instruction stream, numerically ordering labels.\n\t */\n\tstruct code_element *ce = code_head->next;\n\twhile (ce != code_tail) {\n\t\tswitch (ce->type) {\n\t\tcase ET_LABEL:\n\t\t\t{\n\t\t\t\tstruct code_element_label *cel = (struct code_element_label *)ce;\n\t\t\t\tcel->number = lnum++;\n\n\t\t\t\tcel->name = (char *)malloc(32 * sizeof(char));\n\t\t\t\tif (!cel->name) {\n\t\t\t\t\tfprintf(stderr, \"failed to insert label name\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tsprintf(cel->name, \"L%d\", cel->number);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ET_OPCODE:\n\t\t\t{\n\t\t\t\tstruct code_element_opcode *ceo = (struct code_element_opcode *)ce;\n\t\t\t\topcode_counts[ceo->opcode]++;\n\t\t\t\ttotal_insns++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ET_SYMBOL:\n\t\t\t{\n\t\t\t\tstruct code_element_symbol *ces = (struct code_element_symbol *)ce;\n\t\t\t\tif (elf_strings && ces->str_offs) {\n\t\t\t\t\tces->name = elf_strings + ces->str_offs; \n\t\t\t\t} else {\n\t\t\t\t\tces->name = \"UNDEF\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tce = ce->next;\n\t}\n\n\treturn true;\n}\n\n/*\n * code_unpack()\n */\nstatic bool code_unpack(uint32_t addr, uint32_t *insns, int count)\n{\n\tstruct code_element *orig_head = code_tail->prev;\n\tstruct code_element *orig_tail = code_tail;\n\tstruct code_element *head = orig_head;\n\tstruct code_element *tail = orig_tail;\n\tuint32_t *op = insns;\n\n\tfor (int i = 0; i < count; i++, op++) {\n\t\tstruct code_element_opcode *ceo = (struct code_element_opcode *)malloc(sizeof(struct code_element_opcode));\n\t\tif (!ceo) {\n\t\t\tfprintf(stderr, \"Failed to alloc space for opcode\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tstruct code_element *ce = (struct code_element *)ceo;\n\t\thead->next = ce;\n\t\tce->prev = head;\n\t\ttail->prev = ce;\n\t\tce->next = tail;\n\n\t\tce->type = ET_OPCODE;\n\n\t\tceo->instr = elf_uint32_to_host(*op);\n\t\tceo->addr = addr;\n\t\taddr += 4;\n\t\tceo->label = NULL;\n\t\tceo->src1.mode = OM_UNUSED;\n\t\tceo->src2.mode = OM_UNUSED;\n\t\tceo->dest.mode = OM_UNUSED;\n\n\t\tdecode_insn(ceo);\n\n\t\thead = ce;\n\t}\n\n\treturn true;\n}\n\n/*\n * symbol_unpack()\n */\nstatic bool symbol_unpack(struct elf32_sym *syms, int count)\n{\n\tstruct code_element *orig_head = code_tail->prev;\n\tstruct code_element *orig_tail = code_tail;\n\tstruct code_element *head = orig_head;\n\tstruct code_element *tail = orig_tail;\n\tstruct elf32_sym *es = syms;\n\n\tfor (int i = 0; i < count; i++, es++) {\n\t\tes->st_name = elf_uint32_to_host(es->st_name);\n\t\tes->st_value = elf_uint32_to_host(es->st_value);\n\t\tes->st_size = elf_uint32_to_host(es->st_size);\n\t\tes->st_shndx = elf_uint16_to_host(es->st_shndx);\n\n\t\tstruct code_element_symbol *ces = (struct code_element_symbol *)malloc(sizeof(struct code_element_symbol));\n\t\tif (!ces) {\n\t\t\tfprintf(stderr, \"Failed to alloc space for symbol\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tstruct code_element *ce = (struct code_element *)ces;\n\t\thead->next = ce;\n\t\tce->prev = head;\n\t\ttail->prev = ce;\n\t\tce->next = tail;\n\n\t\tce->type = ET_SYMBOL;\n\t\tces->type = es->st_info & 0xf;\n\t\tces->addr = es->st_value;\n\t\tces->section = es->st_shndx;\n\t\tces->str_offs = es->st_name;\n\n\t\thead = ce;\n\t}\n\n\treturn true;\n}\n\n/*\n * section_unpack()\n */\nstatic bool section_unpack(struct elf32_shdr *es, unsigned char *fbuf, int section_num)\n{\n\tes->sh_name = elf_uint32_to_host(es->sh_name);\n\tes->sh_type = elf_uint32_to_host(es->sh_type);\n\tes->sh_flags = elf_uint32_to_host(es->sh_flags);\n\tes->sh_addr = elf_uint32_to_host(es->sh_addr);\n\tes->sh_offset = elf_uint32_to_host(es->sh_offset);\n\tes->sh_size = elf_uint32_to_host(es->sh_size);\n\tes->sh_link = elf_uint32_to_host(es->sh_link);\n\tes->sh_info = elf_uint32_to_host(es->sh_info);\n\tes->sh_addralign = elf_uint32_to_host(es->sh_addralign);\n\tes->sh_entsize = elf_uint32_to_host(es->sh_entsize);\n\n\t/*\n\t * Do we have a section header strings section?  If not then this is probably the strings section!\n\t */\n\tif (!elf_shstrings) {\n\t\tif (elf_hdr->e_shstrndx != SHN_UNDEF) {\n\t\t\telf_shstrings = (char *)(fbuf + es->sh_offset);\n\t\t}\n\t}\n\n\tstruct code_element_section *ces = (struct code_element_section *)malloc(sizeof(struct code_element_section));\n\tif (!ces) {\n\t\tfprintf(stderr, \"Failed to alloc space for section\\n\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Insert ourself into the section hash.\n\t */\n\tint hash_idx = section_num % SECTION_HASH_SLOTS;\n\tces->hash_next = section_hash[hash_idx];\n\tsection_hash[hash_idx] = ces;\n\tces->number = section_num;\n\n\tstruct code_element *ce = (struct code_element *)ces;\n\tce->type = ET_SECTION;\n\tif (elf_shstrings) {\n\t\tces->name = elf_shstrings + es->sh_name; \n\t} else {\n\t\tces->name = \"UNDEF\";\n\t}\n\n\tce->next = code_tail;\n\tce->prev = code_tail->prev;\n\tcode_tail->prev->next = ce;\n\tcode_tail->prev = ce;\n\n\t/*\n\t * If this section includes code then unpack it.\n\t */\n\tif (es->sh_flags & SHF_EXECINSTR) {\n\t\tif (!code_unpack(es->sh_addr, (uint32_t *)(fbuf + es->sh_offset), es->sh_size / 4)) {\n\t\t\tfprintf(stderr, \"Failed to unpack instructions\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If this section includes symbol table data then unpack it.\n\t */\n\tif (es->sh_type == SHT_SYMTAB || es->sh_type == SHT_DYNSYM) {\n\t\tif (es->sh_type == SHT_DYNSYM) {\n\t\t\tdynsym_section = section_num;\n\t\t} else {\n\t\t\tsymtab_section = section_num;\n\t\t}\n\n\t\tif (es->sh_entsize != sizeof(struct elf32_sym)) {\n\t\t\tfprintf(stderr, \"Symbol table entry size: %d - expected: %ld\\n\",\n\t\t\t\tes->sh_entsize, sizeof(struct elf32_sym));\n\t\t\treturn false;\n\t\t}\n\t\tif (!symbol_unpack((struct elf32_sym *)(fbuf + es->sh_offset), es->sh_size / es->sh_entsize)) {\n\t\t\tfprintf(stderr, \"Failed to unpack symbols\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If this section includes a string table then reference it.\n\t */\n\tif (es->sh_type == SHT_STRTAB) {\n\t\telf_strings = (char *)(fbuf + es->sh_offset);\n\t}\n\n\treturn true;\n}\n\n/*\n * elf_unpack()\n */\nstatic bool elf_unpack(const char *filename)\n{\n\tint f = open(filename, O_RDONLY);\n\tif (!f) {\n\t\tfprintf(stderr, \"Can't open file: %s\\n\", filename);\n\t\treturn false;\n\t}\n\n\t/*\n\t * How large is our file?\n\t */\n\tstruct stat st;\n\tif (fstat(f, &st) < 0) {\n\t\tfprintf(stderr, \"Failed to stat file: %s\\n\", filename);\n\t\treturn false;\n\t}\n\n\tunsigned char *fbuf = (unsigned char *)malloc(st.st_size);\n\tif (!fbuf) {\n\t\tfprintf(stderr, \"Failed to make space for file: %s\\n\", filename);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Start by reading the whole file into memory.\n\t */\n\tif (read(f, fbuf, st.st_size) < 0) {\n\t\tfprintf(stderr, \"Can't read file: %s\\n\", filename);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Let's look at the header - check this is an ELF file.\n\t */\n\telf_hdr = (struct elf32_hdr *)fbuf;\n\tstruct elf32_hdr *eh = elf_hdr;\n\tif (eh->e_ident[EI_MAG0] != 0x7f\n\t\t\t|| eh->e_ident[EI_MAG1] != 'E'\n\t\t\t|| eh->e_ident[EI_MAG2] != 'L'\n\t\t\t|| eh->e_ident[EI_MAG3] != 'F') {\n\t\tfprintf(stderr, \"Not an ELF file: %s\\n\", filename);\n\t\treturn false;\n\t}\n\n\teh->e_type = elf_uint16_to_host(eh->e_type);\n\teh->e_machine = elf_uint16_to_host(eh->e_machine);\n\teh->e_version = elf_uint32_to_host(eh->e_version);\n\teh->e_entry = elf_uint32_to_host(eh->e_entry);\n\teh->e_phoff = elf_uint32_to_host(eh->e_phoff);\n\teh->e_shoff = elf_uint32_to_host(eh->e_shoff);\n\teh->e_flags = elf_uint32_to_host(eh->e_flags);\n\teh->e_ehsize = elf_uint16_to_host(eh->e_ehsize);\n\teh->e_phentsize = elf_uint16_to_host(eh->e_phentsize);\n\teh->e_phnum = elf_uint16_to_host(eh->e_phnum);\n\teh->e_shentsize = elf_uint16_to_host(eh->e_shentsize);\n\teh->e_shnum = elf_uint16_to_host(eh->e_shnum);\n\teh->e_shstrndx = elf_uint16_to_host(eh->e_shstrndx);\n\n\tif (eh->e_ehsize != sizeof(struct elf32_hdr)) {\n\t\tfprintf(stderr, \"ELF header: e_ehsize: %d bytes - expected: %ld bytes\\n\",\n\t\t\teh->e_ehsize, sizeof(struct elf32_hdr));\n\t\treturn false;\n\t}\n\n\tif (eh->e_shentsize != sizeof(struct elf32_shdr)) {\n\t\tfprintf(stderr, \"ELF header: e_shentsize: %d bytes - expected: %ld bytes\\n\",\n\t\t\teh->e_shentsize, sizeof(struct elf32_shdr));\n\t\treturn false;\n\t}\n\n\t// XXX - add validation of offsets.\n\n\t/*\n\t * Insert dummy section markers so we never have an empty list.\n\t */\n\tstruct code_element_section *ces_h = (struct code_element_section *)malloc(sizeof(struct code_element_section));\n\tif (!ces_h) {\n\t\tfprintf(stderr, \"Failed to alloc space for section\\n\");\n\t\treturn false;\n\t}\n\n\tstruct code_element *ce_h = (struct code_element *)ces_h;\n\tce_h->type = ET_SECTION;\n\tces_h->name = \"START\";\n\tces_h->number = -1;\n\n\tstruct code_element_section *ces_t = (struct code_element_section *)malloc(sizeof(struct code_element_section));\n\tif (!ces_t) {\n\t\tfprintf(stderr, \"Failed to alloc space for section\\n\");\n\t\treturn false;\n\t}\n\n\tstruct code_element *ce_t = (struct code_element *)ces_t;\n\tce_t->type = ET_SECTION;\n\tces_t->name = \"END\";\n\tces_t->number = -1;\n\n\tce_h->next = ce_t;\n\tce_h->prev = NULL;\n\tcode_head = ce_h;\n\n\tce_t->next = NULL;\n\tce_t->prev = ce_h;\n\tcode_tail = ce_t;\n\n\tstruct elf32_shdr *sh = (struct elf32_shdr *)(fbuf + eh->e_shoff);\n\tif (!section_unpack(&sh[eh->e_shstrndx], fbuf, eh->e_shstrndx)) {\n\t\tfprintf(stderr, \"Unable to unpack string section\\n\");\n\t\treturn false;\n\t}\n\n\tfor (int i = 1; i < eh->e_shnum; i++) {\n\t\tif (i == eh->e_shstrndx) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!section_unpack(&sh[i], fbuf, i)) {\n\t\t\tfprintf(stderr, \"Unable to unpack string section\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!insert_labels_and_separators()) {\n\t\tfprintf(stderr, \"Failed to insert labels and separators\\n\");\n\t\treturn false;\n\t}\n\n\tnumber_labels();\n\n\treturn true;\n}\n\n/*\n * dump_operand()\n */\nstatic void dump_operand(struct operand *o, int scale)\n{\n\tswitch (o->mode) {\n\tcase OM_AREG_PLUS_IMM:\n\t\tif (!o->value.oapi.imm) {\n\t\t\tprintf(\"(%s)\", regname[o->value.oapi.areg]);\n\t\t} else {\n\t\t\tprintf(\"%d(%s)\", o->value.oapi.imm * scale, regname[o->value.oapi.areg]);\n\t\t}\n\t\tbreak;\n\n\tcase OM_AREG_PLUS_DREG:\n\t\tprintf(\"(%s,%s)\", regname[o->value.oapd.areg], regname[o->value.oapd.dreg]);\n\t\tbreak;\n\n\tcase OM_AREG_MODIFY:\n\t\t{\n\t\t\tint mval = o->value.oam.modify & 0x8 ? -1 : 0;\n\t\t\tmval &= (~0x7);\n\t\t\tmval |= o->value.oam.modify & 0x7;\n\t\t\tif (o->value.oam.modify & 0x10) {\n\t\t\t\tprintf(\"%d(%s)++\", mval * scale, regname[o->value.oam.areg]);\n\t\t\t} else {\n\t\t\t\tprintf(\"(%s)%d++\", regname[o->value.oam.areg], mval * scale);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OM_REG:\n\t\tprintf(\"%s\", regname[o->value.or.reg]);\n\t\tbreak;\n\n\tcase OM_IMM:\n\t\tprintf(\"#%d\", o->value.oi.imm);\n\t\tbreak;\n\n\tcase OM_UNUSED:\n\t\tprintf(\"unknown\");\n\t}\n}\n\n/*\n * dump_code_opcode_0op()\n */\nstatic void dump_code_opcode_0op(struct code_element_opcode *ceo)\n{\n\tprintf(\"%s\", opcodes[ceo->opcode].name);\n}\n\n/*\n * dump_code_opcode_1op()\n */\nstatic void dump_code_opcode_1op(struct code_element_opcode *ceo)\n{\n\tstruct opcode *o = &opcodes[ceo->opcode];\n\n\tprintf(\"%s \", o->name);\n\tdump_operand(&ceo->src1, o->size);\n}\n\n/*\n * dump_code_opcode_2op()\n */\nstatic void dump_code_opcode_2op(struct code_element_opcode *ceo)\n{\n\tstruct opcode *o = &opcodes[ceo->opcode];\n\n\tprintf(\"%s \", o->name);\n\tdump_operand(&ceo->dest, o->size);\n\tprintf(\", \");\n\tdump_operand(&ceo->src1, o->size);\n}\n\n/*\n * dump_code_opcode_3op()\n */\nstatic void dump_code_opcode_3op(struct code_element_opcode *ceo)\n{\n\tstruct opcode *o = &opcodes[ceo->opcode];\n\n\tprintf(\"%s \", o->name);\n\tdump_operand(&ceo->dest, o->size);\n\tprintf(\", \");\n\tdump_operand(&ceo->src1, o->size);\n\tprintf(\", \");\n\tdump_operand(&ceo->src2, o->size);\n}\n\n/*\n * dump_code_opcode_cmpi()\n */\nstatic void dump_code_opcode_cmpi(struct code_element_opcode *ceo)\n{\n\tstruct opcode *o = &opcodes[ceo->opcode];\n\n\tprintf(\"%s \", o->name);\n\tdump_operand(&ceo->src1, o->size);\n\tprintf(\", \");\n\tdump_operand(&ceo->src2, o->size);\n}\n\n/*\n * dump_code_opcode_call()\n */\nstatic void dump_code_opcode_call(struct code_element_opcode *ceo)\n{\n\tstruct opcode *o = &opcodes[ceo->opcode];\n\n\tprintf(\"%s \", o->name);\n\tdump_operand(&ceo->dest, o->size);\n\tif (ceo->label) {\n\t\tprintf(\", %s ; offset \", ceo->label->name);\n\t} else {\n\t\tprintf(\", <unknown> ; offset \");\n\t}\n\tdump_operand(&ceo->src1, o->size);\n}\n\n/*\n * dump_code_opcode_jmp()\n */\nstatic void dump_code_opcode_jmp(struct code_element_opcode *ceo)\n{\n\tstruct opcode *o = &opcodes[ceo->opcode];\n\n\tif (ceo->label) {\n\t\tprintf(\"%s %s ; offset \", o->name, ceo->label->name);\n\t} else {\n\t\tprintf(\", <unknown> ; offset \");\n\t}\n\tdump_operand(&ceo->src1, o->size);\n}\n\n/*\n * dump_code_opcode()\n */\nstatic void dump_code_opcode(struct code_element *ce)\n{\n\tstruct code_element_opcode *ceo = (struct code_element_opcode *)ce;\n\n\tprintf(\"  %08x: \", ceo->addr);\n\n\tswitch (ceo->opcode) {\n\tcase OP_BKPT:\n\tcase OP_SUSPEND:\n\t\tdump_code_opcode_0op(ceo);\n\t\tbreak;\n\n\tcase OP_FLUSH:\n\tcase OP_IREAD:\n\tcase OP_PREFETCH:\n\tcase OP_RET:\n\tcase OP_SETCSR:\n\tcase OP_SYNC:\n\tcase OP_SYSCALL:\n\tcase OP_SYSRET:\n\t\tdump_code_opcode_1op(ceo);\n\t\tbreak;\n\t\n\tcase OP_BFRVRS:\n\tcase OP_BTST:\n\tcase OP_CALLI:\n\tcase OP_CRCGEN:\n\tcase OP_IWRITE:\n\tcase OP_EXT_1:\n\tcase OP_EXT_2:\n\tcase OP_LEA_1:\n\tcase OP_LEA_2:\n\tcase OP_LEA_4:\n\tcase OP_MAC:\n\tcase OP_MOVE_1:\n\tcase OP_MOVE_2:\n\tcase OP_MOVE_4:\n\tcase OP_MOVEA:\n\tcase OP_MOVEAI:\n\tcase OP_MOVEI:\n\tcase OP_NOT_2:\n\tcase OP_NOT_4:\n\tcase OP_PDEC:\n\tcase OP_PXCNV:\n\tcase OP_PXCNV_T:\n\tcase OP_SWAPB_2:\n\tcase OP_SWAPB_4:\n\t\tdump_code_opcode_2op(ceo);\n\t\tbreak;\n\n\tcase OP_ADD_1:\n\tcase OP_ADD_2:\n\tcase OP_ADD_4:\n\tcase OP_ADDC:\n\tcase OP_AND_1:\n\tcase OP_AND_2:\n\tcase OP_AND_4:\n\tcase OP_ASR_1:\n\tcase OP_ASR_2:\n\tcase OP_ASR_4:\n\tcase OP_BCLR:\n\tcase OP_BFEXTU:\n\tcase OP_BSET:\n\tcase OP_LSL_1:\n\tcase OP_LSL_2:\n\tcase OP_LSL_4:\n\tcase OP_LSR_1:\n\tcase OP_LSR_2:\n\tcase OP_LSR_4:\n\tcase OP_MADD_2:\n\tcase OP_MADD_2_C:\n\tcase OP_MADD_2_T:\n\tcase OP_MADD_2_C_T:\n\tcase OP_MADD_4:\n\tcase OP_MADD_4_C:\n\tcase OP_MADD_4_T:\n\tcase OP_MADD_4_C_T:\n\tcase OP_MACF:\n\tcase OP_MACF_C:\n\tcase OP_MACF_T:\n\tcase OP_MACF_C_T:\n\tcase OP_MACS:\n\tcase OP_MACS_C:\n\tcase OP_MACS_T:\n\tcase OP_MACS_C_T:\n\tcase OP_MACU:\n\tcase OP_MACU_C:\n\tcase OP_MACU_T:\n\tcase OP_MACU_C_T:\n\tcase OP_MACUS:\n\tcase OP_MACUS_C:\n\tcase OP_MACUS_T:\n\tcase OP_MACUS_C_T:\n\tcase OP_MERGE:\n\tcase OP_MSUB_2:\n\tcase OP_MSUB_2_C:\n\tcase OP_MSUB_2_T:\n\tcase OP_MSUB_2_C_T:\n\tcase OP_MSUB_4:\n\tcase OP_MSUB_4_C:\n\tcase OP_MSUB_4_T:\n\tcase OP_MSUB_4_C_T:\n\tcase OP_MSUF:\n\tcase OP_MSUF_C:\n\tcase OP_MSUF_T:\n\tcase OP_MSUF_C_T:\n\tcase OP_MULF:\n\tcase OP_MULF_C:\n\tcase OP_MULF_T:\n\tcase OP_MULF_C_T:\n\tcase OP_MULS:\n\tcase OP_MULS_T:\n\tcase OP_MULS_4:\n\tcase OP_MULU:\n\tcase OP_MULU_T:\n\tcase OP_MULU_4:\n\tcase OP_OR_1:\n\tcase OP_OR_2:\n\tcase OP_OR_4:\n\tcase OP_PXADDS:\n\tcase OP_PXADDS_U:\n\tcase OP_PXBLEND:\n\tcase OP_PXBLEND_T:\n\tcase OP_PXHI:\n\tcase OP_PXHI_S:\n\tcase OP_PXVI:\n\tcase OP_PXVI_S:\n\tcase OP_SHFTD:\n\tcase OP_SHMRG_1:\n\tcase OP_SHMRG_2:\n\tcase OP_SUB_1:\n\tcase OP_SUB_2:\n\tcase OP_SUB_4:\n\tcase OP_SUBC:\n\tcase OP_XOR_1:\n\tcase OP_XOR_2:\n\tcase OP_XOR_4:\n\t\tdump_code_opcode_3op(ceo);\n\t\tbreak;\n\n\tcase OP_JMPF_S_F:\n\tcase OP_JMPLO_S_F:\n\tcase OP_JMPHS_S_F:\n\tcase OP_JMPEQ_S_F:\n\tcase OP_JMPGE_S_F:\n\tcase OP_JMPGT_S_F:\n\tcase OP_JMPHI_S_F:\n\tcase OP_JMPLE_S_F:\n\tcase OP_JMPLS_S_F:\n\tcase OP_JMPLT_S_F:\n\tcase OP_JMPMI_S_F:\n\tcase OP_JMPNE_S_F:\n\tcase OP_JMPPL_S_F:\n\tcase OP_JMPT_S_F:\n\tcase OP_JMPVC_S_F:\n\tcase OP_JMPVS_S_F:\n\tcase OP_JMPF_S_T:\n\tcase OP_JMPLO_S_T:\n\tcase OP_JMPHS_S_T:\n\tcase OP_JMPEQ_S_T:\n\tcase OP_JMPGE_S_T:\n\tcase OP_JMPGT_S_T:\n\tcase OP_JMPHI_S_T:\n\tcase OP_JMPLE_S_T:\n\tcase OP_JMPLS_S_T:\n\tcase OP_JMPLT_S_T:\n\tcase OP_JMPMI_S_T:\n\tcase OP_JMPNE_S_T:\n\tcase OP_JMPPL_S_T:\n\tcase OP_JMPT_S_T:\n\tcase OP_JMPVC_S_T:\n\tcase OP_JMPVS_S_T:\n\tcase OP_JMPF_W_F:\n\tcase OP_JMPLO_W_F:\n\tcase OP_JMPHS_W_F:\n\tcase OP_JMPEQ_W_F:\n\tcase OP_JMPGE_W_F:\n\tcase OP_JMPGT_W_F:\n\tcase OP_JMPHI_W_F:\n\tcase OP_JMPLE_W_F:\n\tcase OP_JMPLS_W_F:\n\tcase OP_JMPLT_W_F:\n\tcase OP_JMPMI_W_F:\n\tcase OP_JMPNE_W_F:\n\tcase OP_JMPPL_W_F:\n\tcase OP_JMPT_W_F:\n\tcase OP_JMPVC_W_F:\n\tcase OP_JMPVS_W_F:\n\tcase OP_JMPF_W_T:\n\tcase OP_JMPLO_W_T:\n\tcase OP_JMPHS_W_T:\n\tcase OP_JMPEQ_W_T:\n\tcase OP_JMPGE_W_T:\n\tcase OP_JMPGT_W_T:\n\tcase OP_JMPHI_W_T:\n\tcase OP_JMPLE_W_T:\n\tcase OP_JMPLS_W_T:\n\tcase OP_JMPLT_W_T:\n\tcase OP_JMPMI_W_T:\n\tcase OP_JMPNE_W_T:\n\tcase OP_JMPPL_W_T:\n\tcase OP_JMPT_W_T:\n\tcase OP_JMPVC_W_T:\n\tcase OP_JMPVS_W_T:\n\t\tdump_code_opcode_jmp(ceo);\n\t\tbreak;\n\n\tcase OP_CALL:\n\t\tdump_code_opcode_call(ceo);\n\t\tbreak;\n\n\tcase OP_CMPI:\n\t\tdump_code_opcode_cmpi(ceo);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%d\", ceo->opcode);\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n * dump_elf()\n */\nstatic void dump_elf(void)\n{\n\tstruct code_element *ce = code_head;\n\n\twhile (ce) {\n\t\tswitch (ce->type) {\n\t\tcase ET_OPCODE:\n\t\t\tdump_code_opcode(ce);\n\t\t\tbreak;\n\n\t\tcase ET_LABEL:\n\t\t\t{\n\t\t\t\tstruct code_element_label *cel = (struct code_element_label *)ce;\n\t\t\t\tif (ce->prev && ce->prev->type == ET_OPCODE) {\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t\tif (cel->call_label) {\n\t\t\t\t\tprintf(\"CL%d: ; refs: %d\\n\", cel->number, cel->refs);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"JL%d: ; refs: %d\\n\", cel->number, cel->refs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ET_BLOCK_SEPARATOR:\n\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\n\t\tcase ET_SECTION:\n\t\t\t{\n\t\t\t\tstruct code_element_section *ces = (struct code_element_section *)ce;\n\t\t\t\tprintf(\"section: %s (%d)\\n\\n\", ces->name, ces->number);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ET_SYMBOL:\n\t\t\t{\n\t\t\t\tstruct code_element_symbol *ces = (struct code_element_symbol *)ce;\n\t\t\t\tprintf(\"symbol: %s - %d @ %08x, sect: %d\\n\", ces->name, ces->type, ces->addr, ces->section);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tce = ce->next;\n\t}\n}\n\n/*\n * dump_stats()\n */\nstatic void dump_stats(void)\n{\n\tprintf(\"Opcode frequencies\\n\");\n\tprintf(\"------------------\\n\\n\");\n\n\tprintf(\"Instructions: %d\\n\\n\", total_insns);\n\n\t/*\n\t * Dump out statistics about the opcodes supported by this ISA.\n\t */\n\tstruct opcode *o = opcodes;\n\tfor (int i = 0; i <= OP_UNUSED; i++, o++) {\n\t\tif (o->isa_bitmap & (1 << (isa_version - 1))) {\n\t\t\tprintf(\"%12s: %7d (%7.4f)%%\\n\", opcodes[i].name, opcode_counts[i],\n\t\t\t\t(float)(opcode_counts[i] / (float)total_insns) * 100.0);\n\t\t}\n\t}\n}\n\n/*\n * main()\n */\nint main(int argc, const char *argv[])\n{\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"usage: sinister <file>\\n\");\n\t\texit(-1);\n\t}\n\n\tif (!elf_unpack(argv[1])) {\n\t\texit(-1);\n\t}\n\n\tdump_elf();\n\tdump_stats();\n\n\t/*\n\t * We really want to clean up resources but for now just let the process exit\n\t * do this for us instead.\n\t */\n\n\treturn 0;\n}\n\n",
      "start": 56
    }
  ],
  "parser_state": {
    "parsing_continuation": false,
    "continuation_state": 0,
    "lexer_state": {
      "in_block_comment": false
    },
    "in_element": false
  }
}